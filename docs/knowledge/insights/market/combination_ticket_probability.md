# 組合せ馬券の確率計算: 単勝確率からどう導くか

単勝（1着）の確率予測と、組合せ馬券（馬連・馬単・ワイド・三連複・三連単）の確率計算は根本的に異なる。この差を理解し、正しく実装することが馬券収益の核心となる。

> 起点: 「1着確率を予測するのと、この馬とこの馬が来るという組合せの確率は、計算方法が変わるのか？」

---

## 1. 結論: 変わる。そしてそこにAIの最大の優位性がある

単勝の確率は「P(Aが1着)」の一次元問題だが、組合せ馬券は**複数の着順の同時確率（同時分布）**を求める多次元問題になる。

```
単勝:  P(A wins) = 0.30
        → これだけで購入判断可能

馬単:  P(A 1着 かつ B 2着)
        → P(A)とP(B)を単純にかけてはいけない

三連単: P(A 1着 かつ B 2着 かつ C 3着)
        → 3つの条件付き確率の連鎖が必要
```

一般ファンがこの計算をできないからこそ、市場に歪みが生まれ、AIの利益源泉になる（market_structural_inefficiencies参照）。

---

## 2. なぜ単純な掛け算ではダメなのか

### 独立性が成立しない

18頭のレースで、各馬の1着確率が以下だとする:

```
A: 30%  B: 20%  C: 15%  D: 10%  ...（合計100%）
```

「AとBが1-2着」の確率を P(A) × P(B) = 0.30 × 0.20 = 6.0% とするのは**間違い**。

理由: **着順は同時に1つの馬しか占められない**。Aが1着になった時点で、残り17頭で2着を争うため、Bの2着確率はBの「元の強さ」と「Aがいなくなった世界」の両方に依存する。

```
× 間違い（独立仮定）:
  P(A1着, B2着) = P(A) × P(B) = 0.30 × 0.20 = 0.060

○ 正しい（条件付き確率）:
  P(A1着, B2着) = P(A1着) × P(B2着 | A1着)
                = 0.30 × P(B2着 | A1着)

  ここで P(B2着 | A1着) ≠ P(B1着) = 0.20
```

### 直感的な説明

「クラスで一番足が速いAくんが1位になった場合、2位はBくんになる確率」は、「Bくんが1位になる確率」とは違う。Aくんという強力なライバルが「消えた」ので、Bくんの相対的な強さが変わるからだ。

---

## 3. Harville公式: 最も基本的なアプローチ

### 概要

1973年にDavid Harvilleが提案した方法。単勝確率（1着確率）だけから、任意の着順組合せの確率を計算できる。

### 考え方

「Aが1着になった後、残りの馬の中でBが最も強い確率」は、Bの勝率を残りの馬の勝率の合計で割ったものに等しい。

```
Harville公式:

  P(A1着, B2着) = P(A) × P(B) / (1 - P(A))

  P(A1着, B2着, C3着) = P(A) × P(B)/(1-P(A)) × P(C)/(1-P(A)-P(B))
```

### 導出の直感

```
Step 1: Aが1着になる確率 = P(A)

Step 2: Aが1着になった世界で、Bが残りの中で最強になる確率
  → 残りの馬の勝率合計 = 1 - P(A)
  → その中でBの占める割合 = P(B) / (1 - P(A))
  → これがP(B2着 | A1着)

Step 3: A1着かつB2着の世界で、Cが残りの中で最強になる確率
  → 残りの馬の勝率合計 = 1 - P(A) - P(B)
  → その中でCの占める割合 = P(C) / (1 - P(A) - P(B))
  → これがP(C3着 | A1着, B2着)

全体:
  P(A1着, B2着, C3着) = P(A) × [P(B)/(1-P(A))] × [P(C)/(1-P(A)-P(B))]
```

### 具体例

```
18頭レース: A=30%, B=20%, C=15%, D=10%, 残り=25%

■ 馬単 A→B:
  P(A1着, B2着) = 0.30 × 0.20/(1-0.30) = 0.30 × 0.2857 = 0.0857 (8.57%)

  cf. 独立仮定: 0.30 × 0.20 = 0.060 (6.0%)
  → Harvilleの方が高い。Aがいなくなるとbの相対的強さが上がるため。

■ 馬単 B→A:
  P(B1着, A2着) = 0.20 × 0.30/(1-0.20) = 0.20 × 0.375 = 0.075 (7.5%)

  ★ A→B (8.57%) ≠ B→A (7.5%)
  → 着順を入れ替えると確率が変わる！これが三連単の着順依存性。

■ 三連単 A→B→C:
  P = 0.30 × 0.20/(1-0.30) × 0.15/(1-0.30-0.20)
    = 0.30 × 0.2857 × 0.30
    = 0.0257 (2.57%)

■ 三連単 A→C→B:
  P = 0.30 × 0.15/(1-0.30) × 0.20/(1-0.30-0.15)
    = 0.30 × 0.2143 × 0.3636
    = 0.0234 (2.34%)

  ★ A→B→C (2.57%) ≠ A→C→B (2.34%)
  → 2着と3着を入れ替えるだけで確率が変わる。
  → オッズが同じなら、EVも変わる。

■ 馬連 A-B（順不同）:
  P(A-B) = P(A1着,B2着) + P(B1着,A2着)
         = 0.0857 + 0.075 = 0.1607 (16.07%)

■ ワイド A-B（2頭とも3着以内）:
  → 後述（より複雑な計算が必要）
```

---

## 4. 各馬券種の確率計算

### 4-1. 単勝・複勝

```
単勝: P(A wins) → モデルの直接出力

複勝: P(A ∈ {1着, 2着, 3着})

  Harvilleによる複勝確率:
    P(A≤3着) = Σ Σ P(i1着, j2着, A3着) for all i,j
             + Σ P(i1着, A2着) for all i（×残りの3着は自動）
             + P(A1着)

  → 全通りの列挙が必要。実用的には:
    P(A≤3着) ≈ 1 - P(A>3着) をシミュレーションで推定する方が簡単
```

### 4-2. 馬単（着順あり2頭）

```
馬単 A→B: P(A1着) × P(B) / (1 - P(A))

必要な計算量: n × (n-1) 通り（18頭で306通り）
```

### 4-3. 馬連（着順なし2頭）

```
馬連 A-B: P(A→B) + P(B→A)
         = P(A) × P(B)/(1-P(A)) + P(B) × P(A)/(1-P(B))

必要な計算量: n(n-1)/2 通り（18頭で153通り）
```

### 4-4. 三連単（着順あり3頭）

```
三連単 A→B→C:
  P(A) × P(B)/(1-P(A)) × P(C)/(1-P(A)-P(B))

必要な計算量: n × (n-1) × (n-2) 通り（18頭で4,896通り）
```

### 4-5. 三連複（着順なし3頭）

```
三連複 A-B-C: 6つの着順パターンの合計
  = P(A→B→C) + P(A→C→B) + P(B→A→C)
  + P(B→C→A) + P(C→A→B) + P(C→B→A)

必要な計算量: n(n-1)(n-2)/6 通り（18頭で816通り）×6パターン
```

### 4-6. ワイド（3着以内の2頭）

```
ワイド A-B: P(AとBがともに3着以内)

これが最も計算が複雑。007で松風が言及した方法:
  P(ワイドA-B) = Σ_{k≠A,B} P(上位3頭が{A,B,k}の6着順パターン全ての合計)

  つまり「3着に来る残り1頭」を全候補で回す:
  P(ワイドA-B) = Σ_{k=1,k≠A,B}^{n} [P(A→B→k) + P(A→k→B) + P(B→A→k)
                                     + P(B→k→A) + P(k→A→B) + P(k→B→A)]

必要な計算量: n(n-1)/2 通り × (n-2) × 6 パターン
  18頭: 153 × 16 × 6 = 14,688回のHarville計算

★これが007で松風がバグを出した箇所。計算が複雑なため間違えやすい。
```

### 4-7. 枠連

```
枠連 X-Y: 枠Xに属する馬のいずれかと枠Yに属する馬のいずれかが1-2着

  P(枠連X-Y) = Σ_{a∈X, b∈Y} P(馬連a-b) + Σ_{a∈X, a'∈X, a≠a'} P(馬連a-a')
               （同枠の場合は2番目の項が加わる）

枠に複数頭いる場合の計算が必要。
```

---

## 5. Harville公式の限界と修正

### 5-1. 既知のバイアス

Harvilleモデルには体系的なバイアスがあることが学術的に知られている:

```
Harvilleのバイアス:
  - 1着が本命馬の場合、2着以降に本命馬が来る確率を過大評価する
  - 1着が穴馬の場合、2着以降に穴馬が来る確率を過小評価する

  直感的な理由:
    Harvilleは「各馬の強さが一定」と仮定している。
    しかし現実には:
    - 本命馬は安定して好走するが「ぶっちぎり勝ち」は少ない
      → 2着に残る確率はHarvilleの予測より低い
    - 穴馬は「ハマれば勝つが、ダメなときは大敗」
      → 勝つ条件と2着に残る条件が異なる

  学術的表現:
    Harvilleは着順の生成過程をガンマ分布のorder statisticとして
    モデル化しているが、shape parameter = 1（指数分布）を仮定。
    実際にはshape > 1（強い馬は着順の分散が小さい）の可能性。
```

### 5-2. Heneryモデル（修正Harville）

```
Heneryモデル（1981年）:
  Harvilleの仮定を緩和し、着順ごとに異なるpower parameterを導入。

  P(B2着 | A1着) = P(B)^γ / Σ_{k≠A} P(k)^γ

  γ = 1: Harvilleと同じ
  γ < 1: 本命と穴の差を縮小（現実に近い）
  γ > 1: 本命と穴の差を拡大

  実証研究では γ ≈ 0.81 程度が報告されている。

  意味: 2着争いでは、1着争いほど「強い馬が圧倒的に有利」ではない。
  → 穴馬が2着3着に来る確率はHarvilleの予測より高い。
```

### 5-3. 実用的な対処法

```
選択肢:

A. 素のHarvilleをそのまま使う
   利点: 実装が最も簡単、計算が高速
   欠点: 体系的バイアスがある
   適用: まずこれでベースラインを作り、EV計算の精度を見る

B. HeneryモデルでHarvilleを補正する
   利点: バイアスが軽減される
   欠点: γの推定が必要（追加のパラメータ）
   適用: Harvilleの精度が不十分な場合に移行

C. シミュレーションベース
   利点: モデルの仮定に縛られない
   欠点: 計算コストが高い
   適用: 最も精度が必要な場面（大口購入等）

D. 着順を直接モデリングする（後述）
   利点: 最も柔軟
   欠点: モデル構築の複雑さが大幅に増す
   適用: 将来の発展形
```

---

## 6. もう一つのアプローチ: 着順確率を直接予測する

### 6-1. 単勝確率から「変換」するのではなく、直接モデリング

```
アプローチA（変換型）: ★推奨（初期段階）
  Step 1: 各馬の1着確率を予測（LightGBM等）
  Step 2: Harville公式で組合せ確率に変換
  Step 3: EV計算

アプローチB（直接型）:
  Step 1: 各馬の「1着確率、2着確率、3着確率」を直接予測
  Step 2: 組合せ確率を計算（条件付き確率が必要）
  Step 3: EV計算

アプローチC（生成型）:
  Step 1: レース全体の着順分布をモデリング
  Step 2: モンテカルロサンプリングで組合せ確率を推定
  Step 3: EV計算
```

### 6-2. アプローチBの問題: 整合性

```
問題: 各馬の「2着確率」を独立に予測すると、合計が100%にならない可能性がある。

  例: A: 1着30%, 2着25%, 3着20%
      B: 1着20%, 2着25%, 3着22%
      ...
      全馬の2着確率の合計 = 115%  ← 矛盾！

1着確率はsoftmaxで正規化できるが、
1着/2着/3着の整合性（Aが1着ならAは2着にならない等）を
保つのが難しい。

解決策:
  - Plackett-Luceモデル（ランキング学習の一種）
    → 各馬に「強さパラメータ」を割り当て、着順の同時分布を定義
    → 実はHarville公式と等価（指数分布の仮定の下で）
  - 順序ロジットモデル
  - ニューラルネットワーク + 制約付き出力層
```

### 6-3. アプローチCの利点

```
モンテカルロシミュレーションによる着順生成:

  Step 1: 各馬の「強さ」パラメータを推定（= 1着確率の変換）
  Step 2: 各馬にランダムなパフォーマンス値を生成
          （例: 強さ × ランダム変動）
  Step 3: パフォーマンス値でソート → 着順が決まる
  Step 4: これを10,000回繰り返す
  Step 5: 各組合せの出現頻度 = 確率の推定値

利点:
  - Harvilleの仮定に縛られない
  - パフォーマンス変動の分布を馬ごとに変えられる
    （安定型の馬は分散小、一発型の馬は分散大）
  - 複勝やワイドの計算も自然に出る
  - 脚質の相互影響（逃げ馬同士の共倒れ等）もモデル化可能

欠点:
  - 計算コストが高い（10,000回 × 全レース）
  - パフォーマンス変動の分布設計が難しい
  - 再現性の管理（乱数シード）
```

---

## 7. 馬券種別の実装優先度

### Themisの入力として「どの馬券種のEVをどう計算するか」

```
Phase 1: 単勝 + 複勝（最もシンプル）
  単勝EV = P(A wins) × 単勝オッズ(A)
  複勝EV ≈ P(A≤3着) × 複勝オッズ(A)  ※複勝オッズは確定前は範囲

  必要なモデル出力: 各馬の1着確率（softmax出力）
  複勝確率の推定: Harvilleで近似、またはシミュレーション

Phase 2: 馬連 + 馬単 + 枠連（Harvilleで対応可能）
  馬単EV = P(A→B) × 馬単オッズ(A→B)
  馬連EV = P(A-B) × 馬連オッズ(A-B)

  必要な追加実装: Harville公式の実装
  計算量: 18頭で馬単306通り、馬連153通り → 余裕

Phase 3: ワイド（Harville + 全3着候補の列挙）
  ワイドEV = P(ワイドA-B) × ワイドオッズ(A-B)

  必要な追加実装: 3着候補の全列挙（007の松風方式）
  計算量: 18頭で153通り × 16候補 × 6パターン → やや重いが可能
  ★バグの温床（007の教訓）→ 入念な単体テスト必須

Phase 4: 三連複 + 三連単（計算量との戦い）
  三連単EV = P(A→B→C) × 三連単オッズ(A→B→C)

  必要な追加実装: 全4,896通り（18頭）のHarville計算
  計算量: 大きいがバッチ処理で対応可能
  ★市場の非効率性が最大 → 利益源泉として最も有望
```

---

## 8. 脚質の相互作用: Harvilleでは捉えられないもの

### 着順の独立性仮定の限界

```
Harvilleの暗黙の仮定:
  「Aが1着になった場合のBの2着確率は、Aの脚質や展開に依存しない」

現実:
  AとBがともに逃げ馬の場合:
    → Aが逃げ切ったら、Bはハイペースで潰れている可能性が高い
    → P(B2着 | A1着) << P(B) / (1-P(A))
    → Harvilleは過大評価

  Aが逃げ馬、Bが差し馬の場合:
    → Aが逃げ切り = ペースが緩かった可能性
    → 差し馬Bは届かなかったかもしれない
    → P(B2着 | A1着) はケースバイケース

  Aが差し馬、Bも差し馬の場合:
    → ハイペースで前が潰れた展開なら両方来る
    → P(B2着 | A1着) > P(B) / (1-P(A)) の可能性
    → Harvilleは過小評価
```

### 実用的な対処

```
初期段階: Harvilleで十分
  → 脚質の相互作用は「ノイズ」として許容
  → EV計算の大枠には影響しない

将来の改善:
  1. 脚質ペアの補正係数
     同脚質ペア: Harville × 0.8（共倒れリスク）
     逃げ×差し: Harville × 1.0（中立）
     差し×差し: Harville × 1.1（展開相関）
     → 補正係数は過去データから推定

  2. 展開シミュレーション
     レースの展開（ペース）をシミュレーションし、
     展開ごとの着順確率を計算して平均
     → 計算コスト大だが最も正確

  3. アプローチCのモンテカルロに展開変数を組み込む
     → パフォーマンス変動に脚質間の相関を入れる
```

---

## 9. 実装の具体的な設計案

### 9-1. Harville計算エンジン

```python
# 疑似コード: Harville公式による組合せ確率計算

def harville_exacta(win_probs, horse_a, horse_b):
    """馬単 A→B の確率"""
    pa = win_probs[horse_a]
    pb = win_probs[horse_b]
    return pa * pb / (1 - pa)

def harville_trifecta(win_probs, a, b, c):
    """三連単 A→B→C の確率"""
    pa = win_probs[a]
    pb = win_probs[b]
    pc = win_probs[c]
    return pa * (pb / (1 - pa)) * (pc / (1 - pa - pb))

def harville_quinella(win_probs, a, b):
    """馬連 A-B（順不同）"""
    return harville_exacta(win_probs, a, b) + harville_exacta(win_probs, b, a)

def harville_wide(win_probs, a, b):
    """ワイド A-B（ともに3着以内）"""
    n = len(win_probs)
    horses = list(win_probs.keys())
    prob = 0.0
    for k in horses:
        if k == a or k == b:
            continue
        # {a, b, k}が上位3頭になる6パターン全て
        for perm in permutations([a, b, k]):
            prob += harville_trifecta(win_probs, *perm)
    return prob

def all_trifecta_evs(win_probs, trifecta_odds):
    """全三連単組合せのEVを計算"""
    evs = {}
    horses = list(win_probs.keys())
    for a in horses:
        for b in horses:
            if b == a: continue
            for c in horses:
                if c == a or c == b: continue
                prob = harville_trifecta(win_probs, a, b, c)
                odds = trifecta_odds.get((a, b, c), 0)
                evs[(a, b, c)] = prob * odds
    return evs
```

### 9-2. Themisとの接続

```
予測層（Poseidon相当）の出力:
  → Dict[馬ID, 1着確率]（softmax正規化済み、キャリブレーション済み）

確率変換層（新規）:
  → 入力: 1着確率
  → 処理: Harville公式で各馬券種の組合せ確率を計算
  → 出力: Dict[馬券ID, 的中確率]

Themis（購入決定層）:
  → 入力: Dict[馬券ID, 的中確率] × Dict[馬券ID, オッズ] × バンクロール
  → 出力: List[Tuple[馬券ID, 購入金額]]

★Themisの目隠し原則は維持される。
  Themisは「馬券IDの確率」しか見ないので、
  その確率がHarvilleで計算されたのか、シミュレーションで計算されたのか、
  あるいは直接モデリングで出たのかは知らない。
```

---

## 10. 追加考察

### 10-1. キャリブレーションの重要性が倍増する

```
単勝の場合:
  EV = P(A) × odds(A)
  P(A)の誤差がそのままEVの誤差になる。

三連単の場合:
  EV = P(A) × P(B)/(1-P(A)) × P(C)/(1-P(A)-P(B)) × odds(A→B→C)
  P(A)の誤差が分母にも入るため、誤差が増幅される。

具体例:
  真のP(A) = 0.30 のとき、推定が 0.35 だと:

  単勝EV: 0.35/0.30 = 1.167倍の過大評価

  馬単A→BのEV（P(B)=0.20とする）:
    真: 0.30 × 0.20/(1-0.30) = 0.0857
    推定: 0.35 × 0.20/(1-0.35) = 0.1077
    過大評価: 0.1077/0.0857 = 1.257倍
    → 単勝より誤差が大きい

結論:
  組合せ馬券を扱うほど、キャリブレーション（較正精度）の重要性が増す。
  → H-02（キャリブレーション検証）はPhase 2以降の全てに影響する最優先課題。
```

### 10-2. 「どの馬券種でEV計算するか」は戦略的選択

```
松風の変遷:
  2018年: ワイド + 枠連中心（008）
  2019年: ワイド + 枠連 + 複勝（009、年間+1,739万）
  2020年Q3: 三連単を解放（012、Q3だけで+1億65万）

示唆:
  1. 最初から三連単を狙う必要はない
  2. ワイド/枠連でモデルとパイプラインを検証
  3. キャリブレーション精度が十分になったら三連単に拡張
  4. 拡張は「Harville変換層の追加」だけで済む（Themisは不変）
```

### 10-3. 計算コストの現実的な見積もり

```
1レースあたりの計算量:

  単勝:    18通り → 一瞬
  馬単:    306通り → 一瞬
  馬連:    153通り → 一瞬
  三連単:  4,896通り → 数ミリ秒
  三連複:  816通り × 6 = 4,896回 → 数ミリ秒
  ワイド:  153通り × 16 × 6 = 14,688回 → 数十ミリ秒

1日あたり（36レース × 3場 ≈ 36レース）:
  全馬券種のEV計算: 36 × 約25,000回 ≈ 90万回のHarville計算
  → 数秒〜数十秒で完了。計算コストは問題にならない。

本当のボトルネック:
  - オッズデータの取得と更新
  - 1着確率モデルの推論時間
  - 購入実行の通信時間
```

### 10-4. 仮説検証マスターとの連携

```
新規仮説の提案:

H-23: Harville公式の2着以降バイアスは日本競馬でも存在する
  検証: 過去データで実際の2着確率 vs Harville予測の2着確率を比較
  重要度: ★★（組合せ馬券の精度に直結）
  Phase: 2（ベースラインモデル構築後）

H-24: Henery補正（γ≈0.81）は日本競馬に適用可能か
  検証: γを推定し、Harville vs Heneryの予測精度を比較
  重要度: ★（Harvilleで十分なら不要）
  Phase: 3（Harvilleの限界が見えたら）

H-25: 脚質ペアの相関はHarvilleの予測を有意にずらすか
  検証: 同脚質ペアと異脚質ペアで、Harville予測と実績の乖離を比較
  重要度: ★（将来の精度向上のため）
  Phase: 4
```

---

## アクションアイテム

- [ ] Harville公式の実装（Python）と単体テスト
- [ ] 過去データでHarvilleの精度検証（特に2着以降のバイアス、H-23）
- [ ] ワイドのEV計算の実装と007（松風バグ）を踏まえた入念なテスト
- [ ] キャリブレーション誤差が組合せ馬券のEVに与える影響のシミュレーション
- [ ] H-23, H-24, H-25を仮説検証マスターに追加
- [ ] 馬券種別のEV計算パイプラインの設計（Phase 1→4の段階的拡張）

## タグ

`#確率論` `#馬券戦略` `#モデル` `#三連単` `#オッズ`
